package com.codecounter.stinger.service.summary;

import com.fasterxml.jackson.databind.JsonNode;

import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public final class SummaryH2Store implements AutoCloseable {
    private final Connection connection;

    private SummaryH2Store(Connection connection) {
        this.connection = connection;
    }

    public static SummaryH2Store open(Path h2Dir, Path h2DbPathPrefix) throws Exception {
        Files.createDirectories(h2Dir);
        String url = "jdbc:h2:file:" + h2DbPathPrefix.toAbsolutePath().normalize();
        Connection conn = DriverManager.getConnection(url, "sa", "");
        conn.setAutoCommit(true);
        return new SummaryH2Store(conn);
    }

    public void ensureSchema() throws SQLException {
        try (Statement st = connection.createStatement()) {
            st.executeUpdate("CREATE TABLE IF NOT EXISTS APPLICATION (" +
                "  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "  name VARCHAR(512) NOT NULL," +
                "  version VARCHAR(256)," +
                "  root_path VARCHAR(2048)," +
                "  run_folder VARCHAR(128) NOT NULL," +
                "  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP" +
                ")");
            st.executeUpdate("CREATE UNIQUE INDEX IF NOT EXISTS UX_APPLICATION_NAME_RUN ON APPLICATION(name, run_folder)");
            st.executeUpdate("CREATE INDEX IF NOT EXISTS IX_APPLICATION_NAME ON APPLICATION(name)");

            st.executeUpdate("CREATE TABLE IF NOT EXISTS NODE (" +
                "  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "  application_id BIGINT NOT NULL," +
                "  full_path VARCHAR(4096) NOT NULL," +
                "  element_type VARCHAR(32) NOT NULL," +
                "  name VARCHAR(1024) NOT NULL," +
                "  granularity VARCHAR(32) NOT NULL," +
                "  file_type VARCHAR(32) NOT NULL," +
                "  summary_json CLOB NOT NULL," +
                "  summary_markdown CLOB," +
                "  executive_summary CLOB," +
                "  technical_breakdown CLOB," +
                "  dataflow CLOB," +
                "  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP," +
                "  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP," +
                "  CONSTRAINT FK_NODE_APPLICATION FOREIGN KEY (application_id) REFERENCES APPLICATION(id) ON DELETE CASCADE" +
                ")");
            st.executeUpdate("CREATE UNIQUE INDEX IF NOT EXISTS UX_NODE_APP_PATH_TYPE ON NODE(application_id, full_path, element_type)");
            st.executeUpdate("CREATE INDEX IF NOT EXISTS IX_NODE_APP_ELEMENT ON NODE(application_id, element_type)");
            st.executeUpdate("CREATE INDEX IF NOT EXISTS IX_NODE_APP_PATH ON NODE(application_id, full_path)");

            st.executeUpdate("CREATE TABLE IF NOT EXISTS PROCESSING_STATE (" +
                "  application_id BIGINT NOT NULL," +
                "  k VARCHAR(256) NOT NULL," +
                "  v CLOB NOT NULL," +
                "  PRIMARY KEY (application_id, k)," +
                "  CONSTRAINT FK_PROCESSING_STATE_APPLICATION FOREIGN KEY (application_id) REFERENCES APPLICATION(id) ON DELETE CASCADE" +
                ")");
        }
    }

    public long upsertApplication(String name, String runFolder, String rootPath) throws SQLException {
        try (PreparedStatement ps = connection.prepareStatement(
            "MERGE INTO APPLICATION (name, run_folder, root_path) KEY(name, run_folder) VALUES (?, ?, ?)")) {
            ps.setString(1, name);
            ps.setString(2, runFolder);
            ps.setString(3, rootPath);
            ps.executeUpdate();
        }

        try (PreparedStatement ps = connection.prepareStatement(
            "SELECT id FROM APPLICATION WHERE name = ? AND run_folder = ?")) {
            ps.setString(1, name);
            ps.setString(2, runFolder);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return rs.getLong(1);
                }
            }
        }
        throw new SQLException("Failed to read application id after merge");
    }

    public void putProcessingState(long appId, String key, String value) throws SQLException {
        try (PreparedStatement ps = connection.prepareStatement(
            "MERGE INTO PROCESSING_STATE (application_id, k, v) KEY(application_id, k) VALUES (?, ?, ?)")) {
            ps.setLong(1, appId);
            ps.setString(2, key);
            ps.setString(3, value);
            ps.executeUpdate();
        }
    }

    public boolean nodeExists(long appId, String fullPath, String elementType) throws SQLException {
        try (PreparedStatement ps = connection.prepareStatement(
            "SELECT 1 FROM NODE WHERE application_id = ? AND full_path = ? AND element_type = ?")) {
            ps.setLong(1, appId);
            ps.setString(2, fullPath);
            ps.setString(3, elementType);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        }
    }

    public void upsertNode(long appId, String fullPath, String elementType, String name,
                          String granularity, String fileType,
                          JsonNode summaryJson,
                          String summaryMarkdown,
                          String executiveSummary,
                          String technicalBreakdown,
                          String dataflow) throws SQLException {

        try (PreparedStatement ps = connection.prepareStatement(
            "MERGE INTO NODE (application_id, full_path, element_type, name, granularity, file_type, summary_json, summary_markdown, executive_summary, technical_breakdown, dataflow, updated_at) " +
                "KEY(application_id, full_path, element_type) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)")) {
            ps.setLong(1, appId);
            ps.setString(2, fullPath);
            ps.setString(3, elementType);
            ps.setString(4, name);
            ps.setString(5, granularity);
            ps.setString(6, fileType);
            ps.setString(7, summaryJson.toString());
            ps.setString(8, summaryMarkdown);
            ps.setString(9, executiveSummary);
            ps.setString(10, technicalBreakdown);
            ps.setString(11, dataflow);
            ps.executeUpdate();
        }
    }

    public List<Map<String, String>> getMethodSummariesForFile(long appId, String fileKeyPrefix) throws SQLException {
        List<Map<String, String>> out = new ArrayList<>();
        try (PreparedStatement ps = connection.prepareStatement(
            "SELECT name, executive_summary, summary_markdown FROM NODE WHERE application_id = ? AND element_type = 'method' AND full_path LIKE ? ORDER BY full_path")) {
            ps.setLong(1, appId);
            ps.setString(2, fileKeyPrefix + "%");
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    Map<String, String> m = new HashMap<>();
                    m.put("name", rs.getString(1));
                    m.put("executive_summary", rs.getString(2));
                    m.put("summary_markdown", rs.getString(3));
                    out.add(m);
                }
            }
        }
        return out;
    }

    public List<Map<String, String>> getNodesByPrefix(long appId, String folderPrefix) throws SQLException {
        List<Map<String, String>> out = new ArrayList<>();
        try (PreparedStatement ps = connection.prepareStatement(
            "SELECT full_path, element_type, name, summary_markdown FROM NODE WHERE application_id = ? AND full_path LIKE ? AND element_type IN ('file','folder')")) {
            ps.setLong(1, appId);
            ps.setString(2, folderPrefix + "%");
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    Map<String, String> m = new HashMap<>();
                    m.put("full_path", rs.getString(1));
                    m.put("element_type", rs.getString(2));
                    m.put("name", rs.getString(3));
                    m.put("summary_markdown", rs.getString(4));
                    out.add(m);
                }
            }
        }
        return out;
    }

    public long countNodesForApplication(long appId) throws SQLException {
        try (PreparedStatement ps = connection.prepareStatement("SELECT COUNT(*) FROM NODE WHERE application_id = ?")) {
            ps.setLong(1, appId);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return rs.getLong(1);
                }
            }
        }
        return 0;
    }

    @Override
    public void close() throws Exception {
        connection.close();
    }
}
